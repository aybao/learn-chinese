<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mandarin Audio Quiz — Tones & Pinyin (fixed)</title>
<link rel="stylesheet" href="dark_mode.css" />
<link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="app">
    <div class="panel">
      <h1>Mandarin Audio Quiz — Recognising Tones & Pinyin</h1>
      <div class="inputRow" style="margin-bottom:12px">
        <label for="mode">Mode:</label>
        <select id="mode" aria-label="Mode select">
          <option value="tones">Recognising Tones (single-syllable)</option>
          <option value="pinyin">Recognising Pinyin</option>
        </select>
        <button id="startBtn" class="btn">Start / Next question</button>
        <button id="playBtn" class="secondary">Play audio again</button>
        <label style="margin-left:auto"><input type="checkbox" id="autoplay" checked /> Autoplay next</label>
      </div>

      <div id="promptArea" style="min-height:72px">
        <div id="prompt" class="muted">Press <strong>Start / Next question</strong> to begin. Only audio will be played; text is hidden until you answer.</div>
      </div>

      <div id="tonesUI" style="display:none;margin-top:10px">
        <label for="toneInput">Enter tone (0 = neutral, 1-4):</label>
        <input id="toneInput" type="number" min="0" max="4" inputmode="numeric" aria-label="tone input" />
        <button id="submitTone" class="secondary">Submit</button>
      </div>

      <div id="pinyinUI" style="display:none;margin-top:10px">
        <label for="pinyinInput">Type pinyin (prefer numbered tones, e.g. <code>ni3 hao3</code>):</label>
        <input id="pinyinInput" type="text" aria-label="pinyin input" placeholder="ni3 hao3" />
        <button id="submitPinyin" class="secondary">Submit</button>
      </div>

      <div class="score small" id="score">Score: 0 / 0</div>
      <div class="answer" id="answer" aria-live="polite"></div>
      <div class="hint small" id="hint"></div>
    </div>
  </div>

<script>
// -------------------------------
// Data (test cases)
// -------------------------------
// This list intentionally contains single-syllable items for tone recognition
// and multi-syllable items for pinyin recognition.
const WORDS = [
  // single-syllable (tone recognition useful)
  { mandarin: '妈', pinyin: 'ma1', tone: 1 },
  { mandarin: '麻', pinyin: 'ma2', tone: 2 },
  { mandarin: '马', pinyin: 'ma3', tone: 3 },
  { mandarin: '骂', pinyin: 'ma4', tone: 4 },
  { mandarin: '吗', pinyin: 'ma0', tone: 0 }, // neutral
  { mandarin: '我', pinyin: 'wo3', tone: 3 },
  { mandarin: '你', pinyin: 'ni3', tone: 3 },
  { mandarin: '是', pinyin: 'shi4', tone: 4 },
  // multi-syllable (pinyin recognition)
  { mandarin: '你好', pinyin: 'ni3 hao3', tone: null },
  { mandarin: '谢谢', pinyin: 'xie4 xie', tone: null },
  { mandarin: '我不懂', pinyin: 'wo3 bu4 dong3', tone: null },
  { mandarin: '多少钱？', pinyin: 'duo1 shao0 qian2', tone: null }
];

// -------------------------------
// State
// -------------------------------
let queue = [];
let current = null;
let correct = 0, total = 0;
let userInteracted = false; // becomes true after first user gesture (click)

// DOM
const modeEl = document.getElementById('mode');
const startBtn = document.getElementById('startBtn');
const playBtn = document.getElementById('playBtn');
const autoplayEl = document.getElementById('autoplay');
const promptEl = document.getElementById('prompt');
const tonesUI = document.getElementById('tonesUI');
const pinyinUI = document.getElementById('pinyinUI');
const toneInput = document.getElementById('toneInput');
const pinyinInput = document.getElementById('pinyinInput');
const submitTone = document.getElementById('submitTone');
const submitPinyin = document.getElementById('submitPinyin');
const scoreEl = document.getElementById('score');
const answerEl = document.getElementById('answer');
const hintEl = document.getElementById('hint');

// -------------------------------
// Utilities
// -------------------------------
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } }
function countSyllables(pinyin){ if(!pinyin) return 0; return pinyin.trim().split(/\s+/).filter(Boolean).length; }
function normalizePinyinForCompare(s){ // lowercase, normalize whitespace
  return (s||'').toLowerCase().replace(/[^a-z0-9\s]/g,'').replace(/\s+/g,' ').trim();
}
function stripToneNumbers(s){ return (s||'').replace(/[0-5]/g,'').replace(/\s+/g,' ').trim().toLowerCase(); }

// -------------------------------
// Speech (Web Speech API) with fallback to WebAudio beep
// -------------------------------
function speakMandarin(text){
  return new Promise((resolve,reject)=>{
    if(!text){ resolve(); return; }
    // prefer SpeechSynthesis
    const synth = window.speechSynthesis;
    if(synth){
      const utter = new SpeechSynthesisUtterance(text);
      utter.lang = 'zh-CN';
      // try to pick a Chinese voice if available
      const voices = synth.getVoices();
      const zh = voices.find(v=>v.lang && v.lang.toLowerCase().startsWith('zh')) || voices.find(v=>/chinese|zh/i.test(v.name));
      if(zh) utter.voice = zh;
      utter.onend = () => resolve();
      utter.onerror = (e) => {
        console.warn('SpeechSynthesis error', e);
        // fallback to beep
        fallbackBeep().then(resolve).catch(reject);
      };
      try{
        synth.cancel(); // cancel queued utterances to make replay responsive
        synth.speak(utter);
      }catch(err){
        console.warn('speak failed',err);
        fallbackBeep().then(resolve).catch(reject);
      }
    } else {
      // no speechSynthesis support -> fallback
      fallbackBeep().then(resolve).catch(reject);
    }
  });
}

function fallbackBeep(){
  return new Promise((resolve)=>{
    try{
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = 'sine'; o.frequency.value = 600;
      o.connect(g); g.connect(ctx.destination);
      g.gain.setValueAtTime(0.0001, ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.1, ctx.currentTime + 0.01);
      o.start();
      g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.35);
      setTimeout(()=>{ o.stop(); ctx.close(); resolve(); }, 400);
    }catch(e){ console.warn('beep failed',e); resolve(); }
  });
}

// -------------------------------
// Queue building
// -------------------------------
function buildQueue(){
  const mode = modeEl.value;
  if(mode === 'tones'){
    // only single-syllable words
    queue = WORDS.filter(w => countSyllables(w.pinyin) === 1 && typeof w.tone === 'number');
  } else {
    queue = WORDS.slice();
  }
  shuffle(queue);
}

// -------------------------------
// Flow control: present question, check answer, advance
// -------------------------------
async function presentNext(){
  if(queue.length === 0){ promptEl.innerHTML = '<span class="muted">No items in queue for this mode.</span>'; current=null; return; }
  current = queue.shift();
  answerEl.textContent = '';
  hintEl.textContent = '';
  // show minimal prompt (hidden text), only audio played
  promptEl.innerHTML = '<div class="muted">Listen and answer — only audio will be provided.</div>';
  // clear inputs
  toneInput.value = '';
  pinyinInput.value = '';
  // attempt to play audio if user has interacted (browser autoplay rules)
  try{
    if(userInteracted){
      await speakMandarin(current.mandarin);
    } else {
      // do not auto-play before user gesture; user can press Play
    }
  }catch(e){ console.warn('Audio play error', e); }
}

// user explicitly pressed Play
async function handlePlay(){
  userInteracted = true;
  if(!current){ await presentNext(); return; }
  try{ await speakMandarin(current.mandarin); }catch(e){ console.warn('play failed',e); }
}

// submit handlers
function checkToneSubmission(){
  if(!current){ return; }
  const raw = toneInput.value;
  const guess = parseInt(raw,10);
  total += 1;
  let isCorrect = false;
  if(!Number.isNaN(guess) && current.tone !== null && guess === current.tone){ isCorrect = true; correct += 1; }
  // reveal answer
  if(isCorrect){ answerEl.textContent = `Correct — ${current.mandarin} (${current.pinyin})`; }
  else { answerEl.textContent = `Wrong — correct: ${current.tone} — ${current.mandarin} (${current.pinyin})`; }
  updateScore();
  // advance after short delay
  scheduleNextIfAny();
}

function checkPinyinSubmission(){
  if(!current){ return; }
  const raw = pinyinInput.value.trim();
  total += 1;
  const expected = current.pinyin || '';
  const normRaw = normalizePinyinForCompare(raw);
  const normExpected = normalizePinyinForCompare(expected);
  let isCorrect = false;
  if(normRaw === normExpected && normRaw.length>0) {
    isCorrect = true; correct += 1;
  }
  // partial: base letters equal but tone numbers missing/different
  const baseRaw = stripToneNumbers(raw);
  const baseExpected = stripToneNumbers(expected);
  if(isCorrect){
    answerEl.textContent = `Correct — ${current.mandarin} (${current.pinyin})`;
  } else if(baseRaw === baseExpected && baseRaw.length>0){
    answerEl.textContent = `Close — tones differ or missing. Correct: ${current.pinyin} — ${current.mandarin}`;
  } else {
    answerEl.textContent = `Wrong — correct: ${current.pinyin} — ${current.mandarin}`;
  }
  updateScore();
  scheduleNextIfAny();
}

function scheduleNextIfAny(){
  const autoplay = autoplayEl.checked;
  // if autoplay is enabled, present next after a short delay so user can see the answer
  if(autoplay){ setTimeout(()=>{ presentNext().then(()=>{ if(userInteracted) speakMandarin(current.mandarin).catch(()=>{}); }); }, 1100); }
  else { current = null; promptEl.innerHTML = '<div class="muted">Press "Start / Next question" when ready.</div>'; }
}

function updateScore(){ scoreEl.textContent = `Score: ${correct} / ${total}`; }

// -------------------------------
// Event wiring
// -------------------------------
startBtn.addEventListener('click', async ()=>{
  userInteracted = true;
  buildQueue();
  await presentNext();
  // if autoplay and user clicked start, play immediately
  if(autoplayEl.checked) speakMandarin(current.mandarin).catch(()=>{});
});

playBtn.addEventListener('click', ()=>{ handlePlay(); });

modeEl.addEventListener('change', ()=>{
  // show correct UI
  if(modeEl.value === 'tones'){
    tonesUI.style.display = 'block'; pinyinUI.style.display = 'none';
  } else { tonesUI.style.display = 'none'; pinyinUI.style.display = 'block'; }
  // rebuild queue but do not start until user clicks Start
  buildQueue();
  current = null; promptEl.innerHTML = '<div class="muted">Press <strong>Start / Next question</strong> to begin.</div>';
});

submitTone.addEventListener('click', checkToneSubmission);
toneInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ e.preventDefault(); checkToneSubmission(); }});

submitPinyin.addEventListener('click', checkPinyinSubmission);
pinyinInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ e.preventDefault(); checkPinyinSubmission(); }});

// load voices on some browsers
if(window.speechSynthesis){ window.speechSynthesis.onvoiceschanged = ()=>{ /* allow getVoices to populate */ }; }

// initial UI state
modeEl.dispatchEvent(new Event('change'));
updateScore();

// Debug: expose internals in console for developer testing
window.__MANDARIN_QUIZ = {WORDS, buildQueue, presentNext};
</script>
</body>
</html>
